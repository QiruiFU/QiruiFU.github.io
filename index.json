[{"categories":null,"content":"Implicit Update Scheme for MPM","date":"2025-04-12","objectID":"/implicit-mpm-blog/","tags":["simulation"],"title":"Implicit MPM","uri":"/implicit-mpm-blog/"},{"categories":null,"content":"Implicit Update Scheme for MPM The main purpose of this article is to talk about how to apply implicit update in MPM framework. To know more details about MPM, you can read This SIGGRAPH 2016 Course Notes and A Material Point Method For Snow Simulation (Alexey Stomakhin et al., 2013) . ","date":"2025-04-12","objectID":"/implicit-mpm-blog/:0:0","tags":["simulation"],"title":"Implicit MPM","uri":"/implicit-mpm-blog/"},{"categories":null,"content":"Notations ","date":"2025-04-12","objectID":"/implicit-mpm-blog/:1:0","tags":["simulation"],"title":"Implicit MPM","uri":"/implicit-mpm-blog/"},{"categories":null,"content":"Framework of MPM Currently, I prefer to use APIC scheme to transfer velocity between particles and grids. The framework I always use is listed here: Particle to Grid Update Velocities on Grids Grid to Particle Advect Particles Update Deformation Gradient $\\mathbf{F}$ on Particles The main difference between explicit and implicit MPM is “Update Velocities on Grids” step. In explicit MPM, we use $u_{i}^{n+1}=u_{i}^{n} + \\Delta tm_i^{-1}(\\mathbf{f}_{i}^{n}+m\\mathbf{g})$ in this step, where $\\mathbf{f}_i$ is the elastic force and $m\\mathbf{g}$ is gravity. In most implementations, to reduce the computing time, we always compute $\\mathbf{f}_i^n$ in P2G step: $$ \\mathbf{f}^n_i = \\sum_p V_p^0 \\frac{\\partial \\Psi}{\\partial \\mathbf{F}} (F_p^n)^T \\nabla w_{ip} $$ ","date":"2025-04-12","objectID":"/implicit-mpm-blog/:2:0","tags":["simulation"],"title":"Implicit MPM","uri":"/implicit-mpm-blog/"},{"categories":null,"content":"Implicit Update on Grid In implicit MPM, we use $u_{i}^{n+1}=u_{i}^{n} + \\Delta tm_i^{-1}( \\mathbf{f}_{i}^{n+1} +m\\mathbf{g})$ to update velocities on grids. Since : $$ \\begin{align*} \\mathbf{f}_{i}^{n+1} \u0026= \\mathbf{f}_{i}^{n} + \\Delta t \\sum_j \\frac{\\partial\\mathbf{f}_i^n}{\\partial\\hat{x}_j} \\frac{\\partial\\hat{x}_j}{\\partial t} \\\\ \u0026= \\mathbf{f}_{i}^{n} + \\Delta t \\sum_j \\frac{\\partial\\mathbf{f}_i^n}{\\partial\\hat{x}_j}v_j^{n+1} \\end{align*} $$ Then we have: $$ \\begin{align*} u_i^{n+1} = u_i^{n} + \\Delta tm_i^{-1}(\\mathbf{f}_{i}^{n}+m\\mathbf{g}) + \\Delta t^2 m_i^{-1} \\sum_j \\frac{\\partial\\mathbf{f}_i^n}{\\partial\\hat{x}_j}v_j^{n+1} \\end{align*} $$ We can use $u^* = u_i^{n} + \\Delta tm_i^{-1}(\\mathbf{f}_{i}^{n}+m\\mathbf{g})$ to represent the velocity in next time step we get in explicit MPM. Finally, we can write all thing in this: $$ \\begin{align*} u_i^{n+1} - \\Delta t^2 m_i^{-1} \\sum_j \\frac{\\partial\\mathbf{f}_i^n}{\\partial\\hat{x}_j}u_j^{n+1} = u^* \\\\ u_i^{n+1} - \\Delta t m_i^{-1} \\sum_j \\frac{\\partial\\mathbf{f}_i^n}{\\partial\\hat{x}_j}\\Delta tu_j^{n+1} = u^* \\\\ u_i^{n+1} - \\Delta t m_i^{-1} \\sum_j \\frac{\\partial\\mathbf{f}_i^n}{\\partial\\hat{x}_j}\\delta \\hat{x}_j = u^* \\\\ u_i^{n+1} - \\Delta t m_i^{-1} \\sum_j \\delta \\mathbf{f}_j = u^* \\\\ \\end{align*} $$ Here, $\\delta \\mathbf{f}_j$ is a function of $u_i^{n+1}$. Thus we can write this equation into a form like: $$ \\mathbf{M}\\mathbf{u}^{n+1} = \\mathbf{u}^* $$ where $\\mathbf{u}^{n+1}$ and $\\mathbf{u}^*$ are two really huge vectors and $\\mathbf{M}$ is a matrix. Right now, our goal is to solve this equation. Since size of $\\mathbf{M}$ is $(3N)\\times(3N)$ in our problem ($N$ is the number of grids), we cannot represent $\\mathbf{M}$ explicitly. But we can compute the effect when it’s applied onto a vector, which means for a give $\\mathbf{u}$, we can give you $\\mathbf{Mu}$. In this way, we can represent $\\mathbf{M}$ and solve this equation. Look at the left hand side of our equation, we only need to compute $\\delta \\mathbf{f}$ to get the result of $\\mathbf{Mu}$. ","date":"2025-04-12","objectID":"/implicit-mpm-blog/:3:0","tags":["simulation"],"title":"Implicit MPM","uri":"/implicit-mpm-blog/"},{"categories":null,"content":"How to Compute $\\delta \\mathbf{f}$ As the computation of $\\mathbf{f}$ has benn shown before, we have: $$ \\begin{align*} \\delta\\mathbf{f}_i \u0026= \\delta\\sum_p V_p^0 \\frac{\\partial \\Psi}{\\partial \\mathbf{F}} (F_p^n)^T \\nabla w_{ip} \\\\ \u0026= \\sum_p V_p^0 (\\delta\\frac{\\partial \\Psi}{\\partial \\mathbf{F}}) (F_p^n)^T \\nabla w_{ip} \\\\ \\end{align*} $$ In different tasks, we have different constitutive models, so we will have different $\\frac{\\partial\\Psi}{\\partial\\mathbf{F}}$ . Here, let’s say we are using (fixed) Corotated model to describe the property of material: $$ \\begin{align*} \\Psi(\\mathbf{F}) = \\mu ||\\mathbf{F} - \\mathbf{R}||^2_F + \\frac{\\lambda}{2}(J-1)^2 \\\\ \\frac{\\partial\\Psi}{\\partial\\mathbf{F}} = 2\\mu(\\mathbf{F}-\\mathbf{R})+\\lambda(J-1)J\\mathbf{F}^{-T} \\end{align*} $$ $J=\\text{det}\\mathbf{F}$ and $\\mathbf{F}$ is written as $\\mathbf{F}=\\mathbf{RS}$ by polar decomposition, where $\\mathbf{S}$ is a symmetric matrix and $\\mathbf{R}$ is an orthonormal matrix. in this model $$ \\delta\\frac{\\partial \\Psi}{\\partial \\mathbf{F}} = 2\\mu(\\delta\\mathbf{F}-\\delta\\mathbf{R})+\\lambda J\\mathbf{F}^{-T}(J\\mathbf{F}^{-T}:\\delta\\mathbf{F}) + \\lambda(J-1)\\delta(J\\mathbf{F}^{-T}) $$ For the details of how we get this equation, you could read the Tech Report of A Material Point Method For Snow Simulation (Alexey Stomakhin et al., 2013). Just a reminder, we need to compute this formula on particles. Firstly, for $\\delta\\mathbf{F}$, it’s: $$ \\delta\\mathbf{F}_p = \\sum_j \\Delta t u_j (\\nabla w_{jp})^T \\mathbf{F}_p $$ Second, $J\\mathbf{F}^{-T}$ is called cofactor matrix of matrix $\\mathbf{F}$. In 3D, it’s : This result is calculated in Matlab. Additionally, for each entry of $\\delta(J\\mathbf{F}^{-T})$, it’s value equals to $\\delta$ value of that entry of $J\\mathbf{F}^{-T}$ . For example, $\\delta(J\\mathbf{F}^{-T})_{00} = \\delta\\mathbf{F}_{11}\\delta\\mathbf{F}_{22}-\\delta\\mathbf{F}_{12}\\delta\\mathbf{F}_{21}$ . In this method, we can calculate $J\\mathbf{F}^{-T}$ and $\\delta(J\\mathbf{F}^{-T})$ The final problem is $\\delta\\mathbf{R}$. We have: $$ \\begin{align*} \\delta\\mathbf{F} \u0026= \\delta\\mathbf{RS} + \\mathbf{R}\\delta\\mathbf{S} \\\\ \\mathbf{R}^T\\delta\\mathbf{F} \u0026= \\mathbf{R}^T\\delta\\mathbf{RS} + \\delta\\mathbf{S} \\\\ \\mathbf{R}^T\\delta\\mathbf{F} - (\\mathbf{R}^T\\delta\\mathbf{F})^T \u0026= \\mathbf{R}^T\\delta\\mathbf{RS} - \\mathbf{S}(\\delta\\mathbf{R})^T\\mathbf{R} \\\\ \\mathbf{R}^T\\delta\\mathbf{F} - (\\mathbf{R}^T\\delta\\mathbf{F})^T \u0026= \\mathbf{R}^T\\delta\\mathbf{RS} + \\mathbf{SR}^T\\delta\\mathbf{R} \\end{align*} $$ The last step is because: $$ \\begin{align*} \\delta(\\mathbf{R}^T\\mathbf{R}) \u0026= \\delta\\mathbf{I} \\\\ \\delta\\mathbf{R}^T\\mathbf{R} + \\mathbf{R}^T\\delta\\mathbf{R} \u0026= 0 \\end{align*} $$ Or we can say $\\mathbf{R}^T\\delta\\mathbf{R}$ is a skew-symmetric matrix. If we define: $$ \\mathbf{R}^T\\delta\\mathbf{F} - (\\mathbf{R}^T\\delta\\mathbf{F})^T = \\mathbf{V} = \\begin{bmatrix} 0 \u0026 d \u0026 e \\\\ -d \u0026 0 \u0026 f \\\\ -e \u0026 -f \u0026 0 \\end{bmatrix} $$ $$ \\mathbf{R}^T\\delta\\mathbf{R} = \\mathbf{U} = \\begin{bmatrix} 0 \u0026 a \u0026 b \\\\ -a \u0026 0 \u0026 c \\\\ -b \u0026 -c \u0026 0 \\end{bmatrix} $$ Then we have $\\mathbf{V} = \\mathbf{US} + \\mathbf{SU}$. In this equation, $d,e,f$ and $\\mathbf{S}$ are known, so we can solve $a, b, c$: The representations of $a, b, c$ are so long that It cannot be shown clearly here :( . An easier way to compute $a, b, c$ is we can convert this equation into : and sovle this easier equation. After getting $a, b, c$, we have $\\mathbf{R}^T\\delta\\mathbf{R}$. Just pre-multiply $\\mathbf{R}$ on it, we can have $\\delta\\mathbf{R}$. ","date":"2025-04-12","objectID":"/implicit-mpm-blog/:4:0","tags":["simulation"],"title":"Implicit MPM","uri":"/implicit-mpm-blog/"},{"categories":null,"content":"Summary By now, you can find the process of implicit update of MPM is really complicated. A main reference of this article is this repo: snow. You can find more details of mathmatics and code in it. Another important material is Optimization Integrator for Large Time Steps (Theodore F. et al., 2015) . I am not very sure what’s the difference between two kinds of methods. ","date":"2025-04-12","objectID":"/implicit-mpm-blog/:5:0","tags":["simulation"],"title":"Implicit MPM","uri":"/implicit-mpm-blog/"},{"categories":null,"content":"Conjugate Gradient Method in Solving Linear Equation System ","date":"2024-11-12","objectID":"/cg-blog/:0:0","tags":["Simulation"],"title":"Conjugate Gradient Method","uri":"/cg-blog/"},{"categories":null,"content":"Linear Equation System In fluid simulation, sometimes we need to solve a Linear Equation System like doing projection in Eulerian fluid. A linear Equation System can be written as a matrix form: $$ Ax = b $$ where $A$ is a $N\\times N$ matrix and $x,b$ are $N\\times 1$ vectors. Actually, we have a lot of methods to solve this problem, like Gauss-Seidel iteration, Gaussian elimination, etc. When simulating fluid, we always use Conjugate Gradient to solve linear system because it’s more quick than other methods. ","date":"2024-11-12","objectID":"/cg-blog/:1:0","tags":["Simulation"],"title":"Conjugate Gradient Method","uri":"/cg-blog/"},{"categories":null,"content":"Convert Solving to Optimizing A really important fact is that if matrix $A$ is a symmetrical matrix, we can consider solving the equation as a mission to find the minimun value of function: $$ f(x) = \\frac{1}{2}x^TAx - bx $$ To find the minimum value, we can guess a value at first, which is $x_0$ . Then use negative gradient as the dirction we will step and step to the lowest point, which is $x_1$. Iterate this loop again and again, we will get lower and lower in the valley and finally we will get the lowest position. This method is “steepest descent method”. In steepest descent method, every time we use $$ -\\nabla f = b - Ax_i $$ as the direction to step. It’s an intuitive choice, but we can find some better direction in global aspect. ","date":"2024-11-12","objectID":"/cg-blog/:2:0","tags":["Simulation"],"title":"Conjugate Gradient Method","uri":"/cg-blog/"},{"categories":null,"content":"A-orthogonal In linear algebra, we define the dot product of two vectors as: $$ (a, b) = a\\cdot b = a^Tb $$ if $(a,b) = 0$ , we say $a$ and $b$ are orthogonal. Now, we define “A-orthogonal”. We say $a$ and $b$ are A-orghogonal if $$ (a,b)^A = a^TAb = 0 $$ With A-orthogonal vectors ${a_1, …, a_n}$ , we can easily find the represent of solution $x$ in such a base: $$ x = \\sum_{k=1}^n \\frac{(a_k, b)}{(a_k, a_k)^A} a_k $$ So the problem is: how to find the A-orthogonal vectors? If you’re good at linear algebra, you might say finding the eigen vectors of A. But it’s not a good idea because calculating eigen vectors is even more difficult than solving the equations. So, we choose to generate them dynamically : First, we can give an arbitrary vector as $a_1$. To generate $a_2$, we choose an arbitrary vector $t_2$ which is not parallel with $a_1$ . Then we can get $a_1$ by: $$ a_1 = t_2 - \\frac{(t_2, a_1)^A}{(a_1, a_1)^A} a_1 $$ For $a_k$, we have an arbitrary vector $t_k$ which is not parallel with $a_i (1\\leq i \u003c k)$ . Then we have : $$ a_k = t_k - \\sum_{i=1}^{k-1} \\frac{(t_k, a_i)^A}{(a_i, a_i)^A} a_i $$ In fact, method above is a Gram–Schmidt process in A-orthogonal. But it’s not efficient enough in solving the linear equation, we can even make it better. ","date":"2024-11-12","objectID":"/cg-blog/:3:0","tags":["Simulation"],"title":"Conjugate Gradient Method","uri":"/cg-blog/"},{"categories":null,"content":"Conjugate Gradient Method In last section, we generate $t_k$ randomly in every iteration. But if we combine it with deepest descent method, we can have a better verison. If we use $-\\nabla f = b - Ax_{k-1}$ as $t_k$ , we can prove (by induction) that: $$ a_k = t_k - \\frac{(t_k, a_{k-1})^A}{(a_{k-1}, a_{k-1})^A} a_{k-1} $$ is A-orthogonal with $a_i (1\\leq i \u003c k)$ , where $x_{k-1}$ is: $$ x = \\sum_{i=1}^{k-1} \\frac{(a_i, b)}{(a_i, a_i)^A} a_i $$ which means we don’t need to run the loop to find the $a_k$ . Now, we have the algrithm for CG : have a initial guess x t = b - A * x a = t x = a.dot(b) / a.Adot(a) * a for i in range(n) : t = b - A * x a = t - t.Adot(a) / a.Adot(a) * a x += a.dot(b) / a.dot(a) * a looks good, right? So why did I mention the deepest descent method? The truth is, if you read this code carefully, you will find that it’s almost same as the code for deepest descent method. The only difference is in deepest descent method we use $t_i = b - A * x_i$ as step direction but in CG we use $a_i$ , which is computed from $t_i$ . ","date":"2024-11-12","objectID":"/cg-blog/:4:0","tags":["Simulation"],"title":"Conjugate Gradient Method","uri":"/cg-blog/"},{"categories":null,"content":"Summarize Right now, we have two different aspects to see the CG method: We need to find $n$ vectors that are A-orthogonal with each other. If we choose $t_k$ smartly, we can avoid the loop. In steepest descent method, using $-\\nabla f$ as direction is not good enough. We can choose a direction that is A-orthogonal with all directions we’ve steped before. In this method we will have at most $n$ steps to destination. Actually, in practice we don’t need to run all $n$ loops. At most time if $b - Ax$ is small enough we can break the loop. If $A$ is ill-conditioned, we will have more steps to make it small enough, so we have some pre-conditioner to make matrix $A$ more “health”. ","date":"2024-11-12","objectID":"/cg-blog/:5:0","tags":["Simulation"],"title":"Conjugate Gradient Method","uri":"/cg-blog/"},{"categories":null,"content":"Reference: An Introduction to the Conjugate Gradient Method Without the Agonizing Pain An English video : Youtube A Mandarin video from Soochow University : Bilibili ","date":"2024-11-12","objectID":"/cg-blog/:5:1","tags":["Simulation"],"title":"Conjugate Gradient Method","uri":"/cg-blog/"},{"categories":null,"content":"Finite Elements Method for Simulating Elastic Body ","date":"2024-06-25","objectID":"/fem-blog/:0:0","tags":["Simulation"],"title":"FEM for Simulating Elastic Body","uri":"/fem-blog/"},{"categories":null,"content":"What do we do in simulating spring-mass system? Recall what we did in simulating Spring-Mass system: Firstly, we describe deformation of springs using $\\mathbf{F} = \\frac{\\mathbf{x}_1 - \\mathbf{x}_2}{l_0}$. Something noticable here is that $\\mathbf{F}$ is a vector and it is related to rotation of springs. Then, we define strain $G = |\\mathbf{F}| - 1$. The purpose of $G$ is that it is a scale and only related to stretch and contraction of springs. So it is exactly what matters in calculating energy. After describing deformation, we use $ \\Psi = \\mu G^2 = \\mu (\\frac{\\mathbf{x}_1 - \\mathbf{x}_2}{l_0}-1)^2 $ to show the potential energy of $dm$ , where the $\\mu$ is Young’s modulus. Actually, the relationship between deformation and energy is found out by physicians (specifically, Hooke), at most time we only use it. So, the total energy of whole spring is $E = \\Psi l_0 = \\frac{1}{2}\\frac{2\\mu}{l_0}(|\\mathbf{x}_1-\\mathbf{x}_2|-l_0)^2$, where the $\\frac{2\\mu}{l_0}$ is $k$, which we’re familiar with in physics class. At last, we use $F = -\\frac{\\partial E}{\\partial \\mathbf{x}}$ to calculate the force of two points of spring. Having force, we can advance the points and finish simulating. An important thing is, density of energy $\\Psi$ is assumed to be equally distributed in the spring, so we can calculate energy using $E = \\Psi l_0$. ","date":"2024-06-25","objectID":"/fem-blog/:1:0","tags":["Simulation"],"title":"FEM for Simulating Elastic Body","uri":"/fem-blog/"},{"categories":null,"content":"So what we are going to do in FEM? Actually, like spring-mass system, in FEM we devide the whole project into different “mesh”. In 2D simulation we always use triangular and in 3D simulation we always use tetrahedron. glasses divided by meshs In FEM, a mesh is like a spring, we can calculate deformation of it and thus calculate energy of it. You can consider a mesh as a high-dimension spring. To be specific, we take an example of triangle mesh. At first, the mesh has no energy, we call it stay in “Reference”. During the simulation, the mesh has displacement, it becomes: We can define the relationship between $\\mathbf{x}$ and $\\mathbf{X}$ : $\\mathbf{x} = \\Phi(\\mathbf{X})$. In linear FEM, we assume $\\Phi$ is a linear function, so $\\mathbf{x = FX + b}$. Then we can calculate $\\mathbf{F = [x_1-x_0, x_2-x_0][X_1-X_0, X_2-X_0]^{-1}}$, where $\\mathbf{F}$ is a $2\\times 2$ matrix. Then, we need a strain $\\mathbf{G}$ to eliminate rotation and advecton in $\\mathbf{F}$. In my code, I use $\\mathbf{G = \\frac{1}{2}(F^TF-I)}$, which is called Green Strain. Next, we should calculate density of energy $\\Psi$ in the mesh. In my code I use StVK model, which says $\\Psi = \\mu ||\\mathbf{G}||_F^2 + \\frac{\\lambda}{2}tr(\\mathbf{G})^2$. In this model, $\\mu = \\frac{k}{2(1+\\nu)}, \\lambda=\\frac{k\\nu}{(1+\\nu)(1-2\\nu)}$, where $k$ is Young’s modulus and $\\nu$ is Poisson’s ratio. With the same assumption in spring-mass system, we can calculate $E = V\\Psi$. Then we can use $-\\frac{\\partial E}{\\partial \\mathbf{x}}$ to calculate force at vertices of triangular. But here is a problem: what is $\\frac{\\partial E}{\\partial \\mathbf{x}}$ ? To be honest, it is really difficult to deduce the final result. In the future I will put it in the Appendix, but now I can tell you the result directly: $$ \\frac{\\partial E}{\\partial \\mathbf{x}} = VP[\\mathbf{X}_2-\\mathbf{X}_0, \\mathbf{X}_1-\\mathbf{X}_0]^{-T} $$ where $P = FG$, which is called Piola-Kirchhoff stress. After caculating force, the main body of simulating is finished. ","date":"2024-06-25","objectID":"/fem-blog/:2:0","tags":["Simulation"],"title":"FEM for Simulating Elastic Body","uri":"/fem-blog/"},{"categories":null,"content":"Results To summarize, the route of the algorithm is similar with simulating spring-mass system. But the FEM is not as simple as I write here. It can also be used to simulate fluid and other phenomenon. And in this article I use some conclusions in continuum mechanics. To research in such field is also a challengable task. You can see my code on github. The input is .msh file, which can be opened in Gmesh. The output is .vtk files in a sequence, which can be visualized in ParaView. The result of my code has been published at bilibili. I get all input files from TetWild. ","date":"2024-06-25","objectID":"/fem-blog/:3:0","tags":["Simulation"],"title":"FEM for Simulating Elastic Body","uri":"/fem-blog/"},{"categories":null,"content":"About Me I am currently a master’s student in the Computer Graphics \u0026 Game Technology(CGGT) program at the University of Pennsylvania. Previously, I received a B.Sc. in Computer Science and Technology from Nanjing University. I am interested in physical simulation and computational physics. I am looking for an opportunity to start a Ph.D. program in the summer of 2026. ","date":"2024-06-18","objectID":"/homepage/:1:0","tags":null,"title":"","uri":"/homepage/"},{"categories":null,"content":"Miscellaneous I love playing soccer and I am a big fan of Real Madrid. I also enjoy watching movies and NFL football games. ","date":"2024-06-18","objectID":"/homepage/:2:0","tags":null,"title":"","uri":"/homepage/"},{"categories":null,"content":"The first blog of this website.","date":"2024-06-18","objectID":"/first-blog/","tags":["life"],"title":"First Blog Here","uri":"/first-blog/"},{"categories":null,"content":"A Start of this Website As a student major in Computer Science, I think it’s really cool to build my own website. In the past, I wrote some blogs in 洛谷. But the blog function has been cancled in 洛谷 now, so I am unable to design the webpage and you can only read the articles in column format(By the way, they’re all written in Chinese). In purpose of recording my feelings and displaying my CV and information like a researcher, I dicide to build this website with help of Hugo. In the future, I am going to upload some articles to this site and share the link in different occations. Hope I will succeed. 祝我成功。 ","date":"2024-06-18","objectID":"/first-blog/:0:0","tags":["life"],"title":"First Blog Here","uri":"/first-blog/"}]